#!/usr/bin/env bash
set -eo pipefail
shopt -s nullglob

function count_pg_containers() {
    echo $(docker ps -a | grep vg_pg | wc -l)
}

function random_string() {
    echo $(cat /dev/urandom | tr -dc 'a-z' | fold -w 16 | head -n 1)
}

function wait_until_up() {
    while :
    do
        set +e
        docker exec "$1" psql --username postgres &>/dev/null
        exit_code=$?
        set -e
        if [[ "$exit_code" -eq 0 ]]; then
            break
        fi
        sleep 1
    done
}

function exec_in() {
    docker exec "$1" psql --username postgres --command "$2" &>/dev/null
}

case "$1" in
    new)
        if [ -z "$2" ]; then
            name=vg_pg_$(count_pg_containers)
        else
            name="$2"
        fi
        docker run \
            --detach \
            --publish-all \
            --name $name \
            postgres \
            &> /dev/null
        wait_until_up $name
        username=$(random_string)
        password=$(random_string)
        database=$(random_string)
        port=$(docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{(index $conf 0).HostPort}}{{end}}' $name)
        exec_in $name "CREATE DATABASE $database;"
        exec_in $name "CREATE USER $username WITH PASSWORD '$password';"
        exec_in $name "GRANT ALL PRIVILEGES ON DATABASE $database TO $username;"
        echo postgresql://$username:$password@localhost:$port/$database
        exit $VG_VALID_EXIT
        ;;
    rm)
        docker stop $(docker ps | grep vg_pg | cut  -d' ' -f1) &> /dev/null
        docker rm $(docker ps -a | grep vg_pg | cut  -d' ' -f1) &> /dev/null
        exit $VG_VALID_EXIT
        ;;
    shell)
        if [ -z "$2" ]; then
            source $VG_ENV_FILE
        else
            DATABASE_URL="$2"
        fi
        docker run \
            --interactive \
            --tty \
            --net=host \
            --name=vg_pg_shell \
            postgres psql --dbname "$DATABASE_URL"
        docker stop vg_pg_shell &> /dev/null
        docker rm vg_pg_shell &> /dev/null
        exit $VG_VALID_EXIT
        ;;
    dump)
        if [ -z "$2" ]; then
            source $VG_ENV_FILE
        else
            DATABASE_URL="$2"
        fi
        docker run \
            --net=host \
            --rm \
            postgres pg_dump \
                --format=custom \
                --no-acl \
                --no-owner \
                --schema=public \
                --dbname="$DATABASE_URL"
        exit $VG_VALID_EXIT
        ;;
    restore)
        url=$(vg pg new)
        cat "$2" | docker run \
            --interactive \
            --net=host \
            --name=vg_pg_restore \
            --attach stdin \
            postgres pg_restore \
                --no-acl --no-owner --schema=public \
                --dbname="$url" \
            &> /dev/null
        docker stop vg_pg_restore &> /dev/null
        docker rm vg_pg_restore &> /dev/null
        echo "$url"
        exit $VG_VALID_EXIT
        ;;
    help)
        echo "    pg new - Create a new, empty, DB container"
        echo "    pg rm - Stop and remove *all* DB containers"
        echo "    pg shell [DATABASE_URL] - Open psql pointed at DATABASE_URL"
        echo "    pg dump [DATABASE_URL] - Run pg_dump on DATABSE_URL"
        echo "    pg restore DUMP_FILE - Create a new DB and fill with DUMP_FILE"
        ;;
    *)
        exit $VG_NOT_IMPLEMENTED_EXIT
        ;;
esac
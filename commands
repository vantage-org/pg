#!/usr/bin/env bash

function count_pg_containers() {
    echo $(docker ps -a | grep "$VG_RUN_PREFIX"_pg_ | wc -l)
}

function random_string() {
    echo $(cat /dev/urandom | tr -dc 'a-z' | fold -w 16 | head -n 1)
}

function wait_until_up() {
    while :
    do
        docker exec "$1" psql --username postgres &>/dev/null
        exit_code=$?
        if [[ "$exit_code" -eq 0 ]]; then
            break
        fi
        sleep 1
    done
}

function exec_in() {
    docker exec "$1" psql --username postgres --command "$2" &>/dev/null
}

case "$1" in
    new)
        name="$VG_RUN_PREFIX"_pg_$(count_pg_containers)
        docker run \
            --detach \
            --publish-all \
            --name $name \
            postgres \
            &> /dev/null
        wait_until_up $name
        username=$(random_string)
        password=$(random_string)
        database=$(random_string)
        port=$(docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{(index $conf 0).HostPort}}{{end}}' $name)
        exec_in $name "CREATE DATABASE $database;"
        exec_in $name "CREATE USER $username WITH PASSWORD '$password';"
        exec_in $name "GRANT ALL PRIVILEGES ON DATABASE $database TO $username;"
        echo postgresql://$username:$password@localhost:$port/$database
        exit $VG_VALID_EXIT
        ;;
    rm)
        if [ -z "$2" ]; then
            docker stop $(docker ps | grep "$VG_RUN_PREFIX"_pg_ | cut  -d' ' -f1) &> /dev/null
            docker rm $(docker ps -a | grep "$VG_RUN_PREFIX"_pg_ | cut  -d' ' -f1) &> /dev/null
        else
            docker stop "$2" &> /dev/null
            docker rm "$2" &> /dev/null
        fi
        exit $VG_VALID_EXIT
        ;;
    shell)
        source "$VG_ENV_FILE"
        docker run \
            --interactive \
            --tty \
            --rm \
            --net=host \
            postgres psql --dbname "$DATABASE_URL"
        exit $VG_VALID_EXIT
        ;;
    dump)
        source "$VG_ENV_FILE"
        docker run \
            --net=host \
            --rm \
            postgres pg_dump \
                --format=custom \
                --no-acl \
                --no-owner \
                --schema=public \
                --dbname="$DATABASE_URL"
        exit $VG_VALID_EXIT
        ;;
    restore)
        url=$(vg pg new)
        cat "$2" | docker run \
            --interactive \
            --net=host \
            --name="$VG_RUN_PREFIX"_pg_restore \
            --attach stdin \
            postgres pg_restore \
                --no-acl --no-owner --schema=public \
                --dbname="$url" \
            &> /dev/null
        docker stop "$VG_RUN_PREFIX"_pg_restore &> /dev/null
        docker rm "$VG_RUN_PREFIX"_pg_restore &> /dev/null
        echo "$url"
        exit $VG_VALID_EXIT
        ;;
    name)
        source "$VG_ENV_FILE"
        if [[ "$DATABASE_URL" =~ ^postgresql://.*@localhost:([0-9]*)/.*$ ]]; then
            port=${BASH_REMATCH[1]}
        fi
        docker ps | grep "$VG_RUN_PREFIX"_pg_ | grep "$port" | cut  -d' ' -f7
        exit $VG_VALID_EXIT
        ;;
    help)
        echo "    pg new - Create a new, empty, DB container"
        echo "    pg rm [NAME] - Stop and remove DB containers"
        echo "    pg shell - Open psql pointed at DATABASE_URL"
        echo "    pg dump - Run pg_dump on DATABSE_URL"
        echo "    pg restore DUMP_FILE - Create a new DB and fill with DUMP_FILE"
        ;;
    *)
        exit $VG_NOT_IMPLEMENTED_EXIT
        ;;
esac